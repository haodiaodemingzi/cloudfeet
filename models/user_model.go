package models

import (
	"fmt"
	"strings"
	"time"

	mysql "github.com/haodiaodemingzi/cloudfeet/common/gmysql"
)

/*
This code is generated by gendry
*/

// Proxy is a mapping object for proxy table in mysql
type User struct {
	ID         int       `db:"id"`
	Name       string    `db:"name"`
	Role       string    `db:"role"`
	Password   string    `db:"password"`
	Country    string    `db:"country"`
	Source     string    `db:"source"`
	CreateTime time.Time `db:"create_time"`
	UpdateTime time.Time `db:"update_time"`
}

//Insert inserts an array of data into table proxy
func (p *User) Insert(data []map[string]interface{}) (int64, error) {
	db := mysql.GetDB()

	tx := db.MustBegin()
	// TODO: 插入数据判断结果,add db prepare
	for _, item := range data {
		_, err := tx.NamedExec(
			`INSERT INTO pac(domain, status, source) 
		VALUES (:domain, :status, :source )`,
			item)
		if err != nil {
			fmt.Println(err.Error())
		}
	}
	err := tx.Commit()
	return 0, err
}

//Insert inserts an array of data into table proxy
func (p *User) AddDomains(data []map[string]interface{}) (int64, error) {
	db := mysql.GetDB()

	var pacSet []map[string]interface{}
	var sql = "SELECT id FROM pac WHERE domain=?"
	stmt, _ := db.Preparex(sql)
	for _, mapItem := range data {
		var pac Pac
		err := stmt.Get(&pac, mapItem["domain"])
		if err != nil {
			logger.Info("get db row failed: ", err.Error())
		}
		if pac.ID > 0 {
			logger.Info("domain is exists", mapItem["domain"])
			break
		}
		pacSet = append(pacSet, mapItem)
	}
	if len(pacSet) > 0 {
		return p.Insert(pacSet)
	}
	return 0, nil
}

// Update updates the table proxy
func (p *User) Update(where, data map[string]interface{}) (int64, error) {
	db := mysql.GetDB()
	// do update string join
	var u []string
	for k, v := range data {
		u = append(u, fmt.Sprintf("%s=:%s", k, v))
	}
	updateStr := strings.Join(u, ",")

	// do join where str
	var w []string
	for k, v := range where {
		data[k] = v
	}
	whereStr := strings.Join(w, ",")

	var sql = "update pac set " + updateStr + whereStr
	rows, err := db.NamedExec(sql, data)
	row, err := rows.RowsAffected()
	if err != nil {
		logger.Info("update rows failed: ", err.Error())
	}
	fmt.Println("update succ:", row)
	return row, err
}

// Update checked domain
func (p *User) UpdateCheckedDomain(data *map[string]interface{}) error {
	db := mysql.GetDB()

	var sql = "update pac set status=? where domain=?"
	tx, err := db.Begin()
	if err != nil {
		panic(err.Error())
	}

	stmt, err := db.Preparex(sql)
	if err != nil {
		logger.Panic(err.Error())
	}
	defer stmt.Close()

	var domainMap = *data
	for k, v := range domainMap {
		// k = domain v = status
		stmt.Exec(v, fmt.Sprintf("%v", k))
	}

	err = tx.Commit()
	return err
}

// Update updates the table proxy
func (p *User) Query(where map[string]interface{}) ([]Pac, error) {
	db := mysql.GetDB()

	limit := fmt.Sprintf("%v", where["limit"])
	delete(where, "limit")
	// do join where str
	var w []string
	for k, _ := range where {
		w = append(w, fmt.Sprintf("%s=:%s", k, k))
	}
	whereStr := strings.Join(w, " and ")

	var sql = "select id, source, domain, status, create_time, update_time from pac where " + whereStr
	if limit != "" {
		sql += " limit " + limit
	}
	logger.Info(sql)
	ns, _ := db.PrepareNamed(sql)
	defer ns.Close()
	rows, _ := ns.Queryx(where)
	pacList := []Pac{}
	for rows.Next() {
		var pacItem = Pac{}
		rows.StructScan(&pacItem)
		fmt.Println(pacItem)
		pacList = append(pacList, pacItem)
	}

	return pacList, nil
}
